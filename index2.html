<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .group text {
        font: 11px sans-serif;
        pointer-events: auto;
    }

    .group path {
        stroke: rgba(114, 0, 6, 0.4);
    }

    path.chord {
        stroke-width: .75;
        fill-opacity: .25;
    }

</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://gka.github.io/chroma.js/libs/chroma.min.js"></script>
<!--<div height="100%" width="100%"> </div>-->
<script>

    var width = 1000,
        height = 1000,
        outerRadius = Math.min(width, height) / 2 - 4,
        innerRadius = outerRadius - 20;

    var format = d3.format(",.3r");

    // Square matrices, asynchronously loaded; origs is the transpose of dests.
    var dests = [],
        origs = [];

    // The chord layout, for computing the angles of chords and groups.
    var layout = d3.layout.chord()
        .sortGroups(d3.descending)
        .sortSubgroups(d3.descending)
        .sortChords(d3.descending)
        .padding(.04);

    // The color scale, for different categories of “worrisome” risk.
//    var fill = d3.scale.ordinal()
//        .domain([0, 1, 2])
//        .range(["#DB704D", "#D2D0C6", "#ECD08D", "#F8EDD3"]);

    // The arc generator, for the groups.
    var arc = d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);

    // The chord generator (quadratic Bézier), for the chords.
    var chord = d3.svg.chord()
        .radius(innerRadius);

    // Add an SVG element for each diagram, and translate the origin to the center.
    var svg = d3.select("body").selectAll("div")
        .data([dests])
        .enter().append("div")
        .style("display", "inline-block")
        .style("width", width + "px")
        .style("height", height + "px")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    // Load our data file…
    d3.csv("assets/philantrophists.csv", item, function(error, data) {
        if (error) throw error;

        var countryByName = d3.map(),
            countryIndex = -1,
            countryByIndex = [];

        // Compute a unique index for each country.
        data.forEach(function(d) {
            if (countryByName.has(d.orig)) d.orig = countryByName.get(d.orig);
            else countryByName.set(d.orig, d.orig = {name: d.orig, index: ++countryIndex, fillcolor: chroma.scale('Set2').colors(50)[++countryIndex]});
            if (countryByName.has(d.dest)) d.dest = countryByName.get(d.dest);
            else countryByName.set(d.dest, d.dest = {name: d.dest, index: ++countryIndex, fillcolor: chroma.scale('Set2').colors(50)[++countryIndex]});
            d.dest.fillcolor = d.fillcolor;
        });

        // Initialize a square matrix of dests and origs.
        for (var i = 0; i <= countryIndex; i++) {
            dests[i] = [];
            origs[i] = [];
            for (var j = 0; j <= countryIndex; j++) {
                dests[i][j] = 0;
                origs[i][j] = 0;
            }
        }

        // Populate the matrices, and stash a map from index to country.
        data.forEach(function(d) {
            dests[d.orig.index][d.dest.index] = d;
            origs[d.dest.index][d.orig.index] = d;
            countryByIndex[d.orig.index] = d.orig;
            countryByIndex[d.dest.index] = d.dest;
        });

        // For each diagram…
        svg.each(function(matrix, j) {
            var svg = d3.select(this);

            // Compute the chord layout.
            layout.matrix(matrix);

            // Add chords.
            svg.selectAll(".chord")
                .data(layout.chords)
                .enter().append("path")
                .attr("class", "chord")
                .style("fill", function(d) {
                    //alert(d.toString());
                    return d.source.value.fillcolor; })
                // .style("stroke", function(d) { return d3.rgb(d.source.value.fillcolor).darker(); })
                .attr("d", chord)
                .append("title")
                .text(function(d) { return d.source.value.dest.name + " has received " + " $" + format(d.source.value) + "RMB from " + d.source.value.orig.name + '.'; });
            // Add groups.
            var g = svg.selectAll(".group")
                .data(layout.groups)
                .enter().append("g")
                .attr("class", "group");

            // Add the group arc.
            g.append("path")
                .style("fill", function(d) {
                    //return d.source.value.fillcolor;
                    return 1;
                })
                .attr("id", function(d, i) { return "group" + d.index + "-" + j; })
                .attr("d", arc)
                .append("title")
                .text(function(d) { return countryByIndex[d.index].name + " " + (j ? "owes" : "has donated") + " $" + format(d.value) + "RMB."; });

            // Add the group label (but only for large groups, where it will fit).
            // An alternative labeling mechanism would be nice for the small groups.
            g.append("text")
                .attr("x", 6)
                .attr("dy", 15)
                .filter(function(d) { return d.value > 110; })
                .append("textPath")
                .attr("xlink:href", function(d) { return "#group" + d.index + "-" + j; })
                .text(function(d) { return countryByIndex[d.index].name; });
        });
    });

    function item(d) {
        d.amount = +d.amount;
        d.valueOf = value; // for chord layout
        d.fillcolor = chroma.scale('Set2').colors(50)[+d.id];
        return d;
    }

    function value() {
        return this.amount;
    }

</script>